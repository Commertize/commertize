import cron from 'node-cron';
import { xApiService } from '../services/xApiService';
import { xContentGeneratorFixed } from '../services/xContentGeneratorFixed';
import DirectXPoster from '../services/directXPoster';
import { xAnalyticsService } from '../services/xAnalytics';

class XScheduler {
  private isRunning = false;
  private lastMentionId: string | null = null;
  private directXPoster = new DirectXPoster();

  start() {
    if (this.isRunning) {
      console.log('X scheduler already running');
      return;
    }

    console.log('Starting X automation scheduler...');

    // Morning posts: 9:00 AM PT (17:00 UTC)
    cron.schedule('0 17 * * *', async () => {
      await this.postMorningContent();
    });

    // Mid-morning posts: 11:00 AM PT (19:00 UTC)  
    cron.schedule('0 19 * * *', async () => {
      await this.postMidMorningContent();
    });

    // Lunch posts: 1:00 PM PT (21:00 UTC)
    cron.schedule('0 21 * * *', async () => {
      await this.postLunchContent();
    });

    // Afternoon posts: 3:00 PM PT (23:00 UTC)  
    cron.schedule('0 23 * * *', async () => {
      await this.postAfternoonContent();
    });

    // Evening content: 5:00 PM PT (01:00 UTC next day)
    cron.schedule('0 1 * * *', async () => {
      await this.postEveningContent();
    });

    // ⚠️ RATE LIMIT SAFE SCHEDULING ⚠️
    // Reduced frequency to respect X API limits (50 posts/day for free tier)
    
    // Engagement monitoring - Every 2 hours (much less aggressive)
    cron.schedule('0 */2 * * *', async () => {
      await this.autonomousEngagementHandling();
    });

    // Strategic follower growth - Every 4 hours (much reduced)
    cron.schedule('0 */4 * * *', async () => {
      await this.strategicFollowerGrowth();
    });

    // Content optimization - Every 6 hours 
    cron.schedule('0 */6 * * *', async () => {
      await this.intelligentContentOptimization();
    });

    // Market-driven posting - Only twice during business hours
    cron.schedule('0 10,15 * * 1-5', async () => {
      await this.marketDrivenPosting();
    });

    // Conversion engagement - Every 3 hours only
    cron.schedule('0 */3 * * *', async () => {
      await this.conversionFocusedEngagement();
    });

    // Weekly analytics: Sunday 8:00 AM PT
    cron.schedule('0 16 * * 0', async () => {
      await this.generateWeeklyAnalytics();
    });

    // Strategic replies: Every 3 hours during active hours
    cron.schedule('0 */3 9-21 * * *', async () => {
      await this.performStrategicReplies();
    });

    // Educational thread: Weekly on Monday 10:00 AM PT  
    cron.schedule('0 18 * * 1', async () => {
      await this.postEducationalThread();
    });

    // Daily analytics tracking: Every evening 6:00 PM PT
    cron.schedule('0 2 * * *', async () => {
      await this.trackDailyAnalytics();
    });

    // REAL-TIME MONITORING: Priority account monitoring every 2 minutes during active hours
    cron.schedule('*/2 9-21 * * *', async () => {
      await this.monitorPriorityAccountsRealTime();
    });

    this.isRunning = true;
    console.log('✅ X automation scheduler started - BASIC PLAN OPTIMIZED');
    console.log('📊 Estimated daily posts: ~12-15 (well under 100 post Basic limit)');
    console.log('- Morning posts: 9:00 AM PT daily');
    console.log('- Mid-morning posts: 11:00 AM PT daily');
    console.log('- Lunch posts: 1:00 PM PT daily');
    console.log('- Afternoon posts: 3:00 PM PT daily');
    console.log('- Evening posts: 5:00 PM PT daily');
    console.log('- Engagement monitoring: Every 2 hours (rate limited)');
    console.log('- Strategic following: Every 4 hours (controlled growth)');
    console.log('- Content optimization: Every 6 hours');
    console.log('- Market-driven posting: 2x daily (business hours only)');
    console.log('- Conversion engagement: Every 3 hours');
    console.log('- Strategic replies: Every 3 hours (9 AM - 9 PM PT)');
    console.log('- Educational thread: Weekly on Monday 10 AM PT');
    console.log('- Daily analytics: Evening 6 PM PT');
    console.log('- REAL-TIME MONITORING: Every 2 minutes (9 AM - 9 PM PT)');
    console.log('- Analytics: Sunday 8:00 AM PT');
    console.log('⚡ All actions respect X API rate limits to prevent suspension');

    // Note: Initial posting removed to prevent duplicate posts on startup
  }

  async postMorningContent() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping morning post');
      return;
    }

    try {
      console.log('Generating morning X content...');
      const content = await xContentGeneratorFixed.generateDailyContent(new Date());
      
      // Use the media generated by xContentGenerator (supports video, GIF, images)
      let mediaFiles: string[] = content.media || [];
      
      console.log(`Generated morning content with ${content.mediaType || 'image'}: ${mediaFiles.length > 0 ? mediaFiles[0].split('/').pop() : 'none'}`);
      
      // If no media generated, create fallback image
      if (mediaFiles.length === 0) {
        try {
          console.log('No media generated, creating fallback image with Commertize logo...');
          const fallbackContent = await xContentGeneratorFixed.getFallbackContent('educational');
          if (fallbackContent.media && fallbackContent.media.length > 0) {
            mediaFiles = fallbackContent.media;
            console.log(`Generated morning fallback image: ${mediaFiles[0].split('/').pop()}`);
          }
        } catch (error) {
          console.error('Failed to generate morning fallback image:', error);
        }
      }
      
      const postData = {
        text: content.text,
        poll: content.poll,
        media: mediaFiles
      };

      await xApiService.postTweet(postData);
      console.log('Morning X post published successfully with Commertize branding');
      
    } catch (error) {
      console.error('Failed to post morning content:', error);
    }
  }

  async postMidMorningContent() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping mid-morning post');
      return;
    }

    try {
      console.log('Generating mid-morning X content...');
      const content = await xContentGeneratorFixed.generateDailyContent(new Date());
      
      // Use the media generated by xContentGenerator (supports video, GIF, images)
      let mediaFiles: string[] = content.media || [];
      
      console.log(`Generated mid-morning content with ${content.mediaType || 'image'}: ${mediaFiles.length > 0 ? mediaFiles[0].split('/').pop() : 'none'}`);
      
      // If no media generated, create fallback image
      if (mediaFiles.length === 0) {
        try {
          console.log('No media generated, creating fallback image with Commertize logo...');
          const fallbackContent = await xContentGeneratorFixed.getFallbackContent('platform_update');
          if (fallbackContent.media && fallbackContent.media.length > 0) {
            mediaFiles = fallbackContent.media;
            console.log(`Generated mid-morning fallback image: ${mediaFiles[0].split('/').pop()}`);
          }
        } catch (error) {
          console.error('Failed to generate mid-morning fallback image:', error);
        }
      }
      
      const postData = {
        text: content.text,
        poll: content.poll,
        media: mediaFiles
      };

      await xApiService.postTweet(postData);
      console.log('Mid-morning X post published successfully with Commertize branding');
      
    } catch (error) {
      console.error('Failed to post mid-morning content:', error);
    }
  }

  async postLunchContent() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping lunch post');
      return;
    }

    try {
      console.log('Generating lunch X content...');
      const content = await xContentGeneratorFixed.generateDailyContent(new Date());
      
      // Use the media generated by xContentGenerator (supports video, GIF, images)
      let mediaFiles: string[] = content.media || [];
      
      console.log(`Generated lunch content with ${content.mediaType || 'image'}: ${mediaFiles.length > 0 ? mediaFiles[0].split('/').pop() : 'none'}`);
      
      // If no media generated, create fallback image
      if (mediaFiles.length === 0) {
        try {
          console.log('No media generated, creating fallback image with Commertize logo...');
          const fallbackContent = await xContentGeneratorFixed.getFallbackContent('weekly_recap');
          if (fallbackContent.media && fallbackContent.media.length > 0) {
            mediaFiles = fallbackContent.media;
            console.log(`Generated lunch fallback image: ${mediaFiles[0].split('/').pop()}`);
          }
        } catch (error) {
          console.error('Failed to generate lunch fallback image:', error);
        }
      }
      
      const postData = {
        text: content.text,
        poll: content.poll,
        media: mediaFiles
      };

      await xApiService.postTweet(postData);
      console.log('Lunch X content posted successfully with Commertize branding');
      
    } catch (error) {
      console.error('Failed to post lunch content:', error);
    }
  }

  async postAfternoonContent() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping afternoon post');
      return;
    }

    try {
      console.log('Generating afternoon X content...');
      const content = await xContentGeneratorFixed.generateDailyContent(new Date());
      
      // Use the media generated by xContentGenerator (supports video, GIF, images)
      let mediaFiles: string[] = content.media || [];
      
      console.log(`Generated afternoon content with ${content.mediaType || 'image'}: ${mediaFiles.length > 0 ? mediaFiles[0].split('/').pop() : 'none'}`);
      
      // If no media generated, create fallback image
      if (mediaFiles.length === 0) {
        try {
          console.log('No media generated, creating fallback image with Commertize logo...');
          const fallbackContent = await xContentGeneratorFixed.getFallbackContent('market_insight');
          if (fallbackContent.media && fallbackContent.media.length > 0) {
            mediaFiles = fallbackContent.media;
            console.log(`Generated afternoon fallback image: ${mediaFiles[0].split('/').pop()}`);
          }
        } catch (error) {
          console.error('Failed to generate afternoon fallback image:', error);
        }
      }
      
      const postData = {
        text: content.text,
        poll: content.poll,
        media: mediaFiles
      };

      await xApiService.postTweet(postData);
      console.log('Afternoon X content posted successfully with Commertize branding');
      
    } catch (error) {
      console.error('Failed to post afternoon content:', error);
    }
  }

  async postEveningContent() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping evening post');
      return;
    }

    try {
      console.log('Generating evening X content...');
      const content = await xContentGeneratorFixed.generateDailyContent(new Date());
      
      // Use the media generated by xContentGenerator (supports video, GIF, images)
      let mediaFiles: string[] = content.media || [];
      
      console.log(`Generated evening content with ${content.mediaType || 'image'}: ${mediaFiles.length > 0 ? mediaFiles[0].split('/').pop() : 'none'}`);
      
      // If no media generated, create fallback image
      if (mediaFiles.length === 0) {
        try {
          console.log('No media generated, creating fallback image with Commertize logo...');
          const fallbackContent = await xContentGeneratorFixed.getFallbackContent('thought_leadership');
          if (fallbackContent.media && fallbackContent.media.length > 0) {
            mediaFiles = fallbackContent.media;
            console.log(`Generated evening fallback image: ${mediaFiles[0].split('/').pop()}`);
          }
        } catch (error) {
          console.error('Failed to generate evening fallback image:', error);
        }
      }
      
      const postData = {
        text: content.text,
        poll: content.poll,
        media: mediaFiles
      };

      await xApiService.postTweet(postData);
      console.log('Evening X content posted successfully with Commertize branding');
      
    } catch (error) {
      console.error('Failed to post evening content:', error);
    }
  }

  async handleEngagement() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      // Get recent mentions
      const mentions = await xApiService.getMentions(this.lastMentionId || undefined);
      
      if (mentions.length === 0) {
        return;
      }

      console.log(`Processing ${mentions.length} new mentions...`);

      for (const mention of mentions) {
        try {
          // Generate contextual response
          const response = await xContentGeneratorFixed.getFallbackContent('engagement');
          
          // Reply to mention
          await xApiService.replyToTweet(mention.id, response.text);
          
          // Like the original mention
          await xApiService.likeTweet(mention.id);
          
          console.log(`Responded to mention from @${mention.author_id}`);
          
          // Rate limiting - wait between responses
          await new Promise(resolve => setTimeout(resolve, 2000));
          
        } catch (error) {
          console.error(`Failed to respond to mention ${mention.id}:`, error);
        }
      }

      // Update last mention ID
      this.lastMentionId = mentions[0].id;
      
    } catch (error) {
      console.error('Failed to handle engagement:', error);
    }
  }

  // Autonomous engagement handling with intelligence
  async autonomousEngagementHandling() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      // Monitor mentions and respond intelligently
      await this.handleEngagement();

      // Proactively engage with relevant CRE content
      await this.proactiveEngagement();

    } catch (error) {
      console.error('Autonomous engagement handling failed:', error);
    }
  }

  // Intelligent content optimization based on performance
  async intelligentContentOptimization() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      console.log('Running intelligent content optimization...');
      
      // Analyze recent post performance and adjust strategy
      const currentHour = new Date().getHours();
      const shouldPost = this.shouldPostBasedOnEngagement(currentHour);

      if (shouldPost) {
        const optimizedContent = await this.generateOptimizedContent();
        if (optimizedContent) {
          await xApiService.postTweet({ text: optimizedContent });
          console.log('Posted optimized content based on engagement patterns');
        }
      }

    } catch (error) {
      console.error('Content optimization failed:', error);
    }
  }

  // Market-driven opportunistic posting
  async marketDrivenPosting() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      console.log('Analyzing market conditions for opportunistic posting...');
      
      // Check if market conditions warrant additional content
      const marketInsight = await this.analyzeMarketConditions();
      if (marketInsight.shouldPost) {
        const content = await xContentGeneratorFixed.getFallbackContent('market_insight');
        await xApiService.postTweet({ text: content.text });
        console.log(`Posted market-driven content: ${marketInsight.topic}`);
      }

    } catch (error) {
      console.error('Market-driven posting failed:', error);
    }
  }

  // Proactive engagement with CRE community
  async proactiveEngagement() {
    try {
      // Search for relevant CRE discussions to engage with
      const relevantTweets = await this.findRelevantCRETweets();
      
      for (const tweet of relevantTweets.slice(0, 5)) { // Increased to 5 engagements per cycle
        const engagementType = this.determineEngagementType(tweet);
        
        if (engagementType === 'like') {
          await xApiService.likeTweet(tweet.id);
          console.log(`Liked tweet about ${tweet.text.substring(0, 50)}...`);
        } else if (engagementType === 'reply') {
          const response = await this.generateConversionFocusedReply(tweet);
          await xApiService.replyToTweet(tweet.id, response);
          console.log(`Replied to tweet about ${tweet.text.substring(0, 50)}...`);
        } else if (engagementType === 'follow') {
          await xApiService.followUser(tweet.author_id);
          await xApiService.likeTweet(tweet.id);
          console.log(`Followed and liked tweet from @${tweet.author_id}`);
        }
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 3000));
      }

      // Strategic follower growth
      await this.strategicFollowerGrowth();

    } catch (error) {
      console.error('Proactive engagement failed:', error);
    }
  }

  // Helper methods for autonomous operation
  private shouldPostBasedOnEngagement(currentHour: number): boolean {
    // Post during high-engagement hours (9-11 AM, 1-3 PM, 7-9 PM PT)
    const highEngagementHours = [9, 10, 11, 13, 14, 15, 19, 20, 21];
    return highEngagementHours.includes(currentHour);
  }

  private async generateOptimizedContent(): Promise<string | null> {
    try {
      // Generate content based on what's performing well
      const topics = [
        'CRE tokenization benefits for property owners',
        'Liquidity solutions in commercial real estate',
        'Fractional ownership democratizing real estate access',
        'Smart contracts revolutionizing property transactions'
      ];
      
      const randomTopic = topics[Math.floor(Math.random() * topics.length)];
      const content = await xContentGeneratorFixed.getFallbackContent('market_insight');
      return content.text;
    } catch (error) {
      console.error('Failed to generate optimized content:', error);
      return null;
    }
  }

  private async analyzeMarketConditions(): Promise<{ shouldPost: boolean; topic: string }> {
    // Simplified market analysis - in reality, this would check various market indicators
    const marketTopics = [
      'Rising interest rates impact on CRE',
      'Office space market trends',
      'Industrial real estate tokenization opportunities',
      'Retail property investment shifts',
      'Multifamily tokenization trends'
    ];

    // Post 30% of the time when called (smart frequency control)
    const shouldPost = Math.random() < 0.3;
    const topic = marketTopics[Math.floor(Math.random() * marketTopics.length)];

    return { shouldPost, topic };
  }

  private async findRelevantCRETweets(): Promise<any[]> {
    try {
      const searchQueries = [
        'commercial real estate tokenization',
        'RWA real world assets blockchain',
        'fractional property ownership',
        'property tokenization platform',
        '@RealBlocks OR @tangible_co OR @lofty_ai',
        '@securitize OR @polymath_net OR @harbor_trade',
        'real estate STO security token',
        'CRE digital assets investment',
        'PropTech blockchain real estate',
        'tokenized commercial property'
      ];

      const allTweets: any[] = [];
      
      // Search each query and collect relevant tweets
      for (const query of searchQueries.slice(0, 4)) { // Increased to 4 for better coverage
        const tweets = await xApiService.searchTweets(query, 10);
        allTweets.push(...tweets);
        
        // Rate limiting between searches
        await new Promise(resolve => setTimeout(resolve, 2000));
      }

      // Filter for quality tweets (avoid spam, focus on accounts with decent following)
      const qualityTweets = allTweets.filter(tweet => {
        const author = tweet.author || {};
        const metrics = author.public_metrics || {};
        return metrics.followers_count > 100 && metrics.followers_count < 100000; // Target mid-tier accounts
      });

      console.log(`Found ${qualityTweets.length} relevant CRE tweets for engagement`);
      return qualityTweets;
      
    } catch (error) {
      console.error('Failed to find relevant CRE tweets:', error);
      return [];
    }
  }

  private determineEngagementType(tweet: any): 'like' | 'reply' | 'follow' | 'none' {
    const text = tweet.text.toLowerCase();
    const author = tweet.author || {};
    const metrics = author.public_metrics || {};
    
    // Follow strategy for high-value accounts
    if ((text.includes('tokenization') || text.includes('rwa') || text.includes('real estate blockchain')) && 
        metrics.followers_count > 500 && metrics.followers_count < 10000) {
      return 'follow';
    }
    
    // Reply to questions, skeptical comments, or collaboration requests
    if (text.includes('question') || text.includes('?') || 
        text.includes('looking for') || text.includes('need help') ||
        text.includes('liquidity') || text.includes('property financing') ||
        text.includes('what is') || text.includes('how does') ||
        text.includes('risky') || text.includes('scam') || 
        text.includes('collab') || text.includes('partner') ||
        text.includes('amazing') || text.includes('future') ||
        text.includes('funding') || text.includes('capital')) {
      return 'reply';
    }
    
    // Like relevant content
    if (text.includes('tokenization') || text.includes('cre') || 
        text.includes('commercial real estate') || text.includes('fractional ownership')) {
      return 'like';
    }
    
    return 'none';
  }

  async generateConversionFocusedReply(tweet: any): Promise<string> {
    try {
      const text = tweet.text.toLowerCase();
      const author = tweet.author || {};
      const metrics = author.public_metrics || {};
      
      // RUNE.CTZ Reply Templates - Conversion-focused with DM funneling
      
      // 1. Basic "What is Commertize?" questions
      if (text.includes('what is') || text.includes('how does') || text.includes('explain') || 
          (text.includes('?') && (text.includes('tokeniz') || text.includes('commertize')))) {
        return "Commertize is the new way to capitalize commercial real estate 🏢💡\nWe tokenize properties → unlock liquidity → give investors access.\nWant me to DM you the whitepaper?";
      }
      
      // 2. Skeptical / Risk concerns
      if (text.includes('risky') || text.includes('risk') || text.includes('concern') || 
          text.includes('how does this work') || text.includes('seems complicated')) {
        return "Fair point 👌 The CRE market is tough right now: high rates, negative equity, foreclosures looming.\nCommertize solves this by tokenizing CRE → creating compliant, asset-backed liquidity.\nTransparency is key. Happy to share proof-of-assets if you'd like.";
      }
      
      // 3. Scam accusations or harsh criticism
      if (text.includes('scam') || text.includes('fraud') || text.includes('fake') || 
          text.includes('ponzi') || text.includes('bullshit')) {
        return "Totally understand the concern. We're not a fly-by-night project—Commertize works within compliance (Reg D 506c, accredited investors only) + fully backed by real-world CRE.\nHappy to send you our compliance guide if you want to check it out.";
      }
      
      // 4. Supportive comments
      if (text.includes('future') || text.includes('amazing') || text.includes('great') || 
          text.includes('love') || text.includes('exciting') || text.includes('support')) {
        return "Thanks for the support 🙌 CRE needs fresh solutions, and tokenization is a game changer.\nCurious—are you more interested in the investor side or the property owner side?";
      }
      
      // 5. Collaboration interest
      if (text.includes('collab') || text.includes('partner') || text.includes('work together') || 
          text.includes('connect') || text.includes('network')) {
        return "Love the idea 🤝 Always open to new partners.\nShoot me a DM with what you're working on & let's see if there's synergy.";
      }
      
      // 6. Investment interest (detect potential investors)
      if ((text.includes('investment') || text.includes('investor') || text.includes('accredited') || 
          text.includes('fund') || text.includes('portfolio')) && 
          (metrics.followers_count > 1000 || text.includes('looking'))) {
        return "We're currently onboarding accredited investors 👔. If you're looking for access to CRE tokenization deals, I can DM you the sign-up link.";
      }
      
      // 7. Property owner leads
      if (text.includes('own') && (text.includes('property') || text.includes('building') || text.includes('real estate')) ||
          text.includes('liquidity') || text.includes('refinanc') || text.includes('capital')) {
        return "If you own CRE and need liquidity, Commertize lets you unlock capital without refinancing headaches. DM me and I'll walk you through how it works.";
      }
      
      // 8. Memes / Lighthearted engagement
      if (text.includes('meme') || text.includes('😂') || text.includes('lol') || 
          text.includes('funny') || text.includes('joke')) {
        return "😂 Tokenizing buildings is serious… but who says we can't have fun doing it? Drop your best CRE meme.";
      }
      
      // 9. General positive engagement with funnel
      if (text.includes('blockchain') || text.includes('tokenization') || text.includes('crypto') || 
          text.includes('defi') || text.includes('rwa')) {
        return "Appreciate you 🚀 The CRE market is broken, and we're here to fix it. Stick around—big things coming.\nWant me to DM you the details?";
      }
      
      // Default: General positive with DM funnel
      return "The CRE market needs fresh solutions, and tokenization changes everything. Traditional financing is broken—we're fixing it.\nHappy to send you the deck if you'd like.";
      
    } catch (error) {
      console.error('Failed to generate RUNE.CTZ reply:', error);
      return "Great point! CRE needs innovation. Commertize is the new way to capitalize commercial real estate.\nLet me know, I'll shoot over the link.";
    }
  }

  async strategicFollowerGrowth() {
    try {
      // Target influential CRE accounts to follow
      const targetAccounts = [
        'REITs', 'CommercialRE', 'CREDaily', 'PropertyNews', 'RealEstateNews',
        'BlockchainRE', 'PropTech', 'RWATokens', 'DeFiRealEstate'
      ];

      // Follow 2-3 strategic accounts per cycle to avoid spam detection
      const accountsToFollow = targetAccounts.slice(0, 2);
      
      for (const username of accountsToFollow) {
        try {
          const user = await xApiService.getUserByUsername(username);
          if (user && user.public_metrics.followers_count > 1000) {
            await xApiService.followUser(user.id);
            console.log(`Strategically followed @${username}`);
            
            // Rate limiting
            await new Promise(resolve => setTimeout(resolve, 5000));
          }
        } catch (error) {
          console.error(`Failed to follow @${username}:`, error);
        }
      }
    } catch (error) {
      console.error('Strategic follower growth failed:', error);
    }
  }

  async conversionFocusedEngagement() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      console.log('Running conversion-focused engagement...');
      
      // Search for tweets asking about CRE solutions
      const conversionQueries = [
        'need commercial real estate financing',
        'looking for property investment platform',
        'real estate liquidity solutions',
        'fractional real estate investment',
        'CRE capital access'
      ];

      const query = conversionQueries[Math.floor(Math.random() * conversionQueries.length)];
      const tweets = await xApiService.searchTweets(query, 10);
      
      for (const tweet of tweets) {
        // Reply with conversion-focused message
        const reply = await this.generateConversionFocusedReply(tweet);
        await xApiService.replyToTweet(tweet.id, reply);
        await xApiService.likeTweet(tweet.id);
        
        console.log('Engaged with conversion opportunity');
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 10000));
      }
      
    } catch (error) {
      console.error('Conversion-focused engagement failed:', error);
    }
  }

  async generateWeeklyAnalytics() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      console.log('📊 Generating comprehensive weekly X analytics report...');
      
      // Use the new analytics service for detailed metrics
      await xAnalyticsService.generateWeeklyReport();
      
      const metrics = await xApiService.getAccountMetrics();
      
      if (metrics) {
        const analyticsPost = `📊 Weekly Update: ${metrics.followers} property professionals following our CRE modernization mission.\n\nFrom archaic to algorithmic, from gatekept to accessible.\n\nJoin the revolution → Commertize.com\n\n#Commertize #WeeklyUpdate #RWA`;
        
        await xApiService.postTweet({ text: analyticsPost });
        console.log('✅ Weekly analytics posted with strategic messaging');
      }
      
    } catch (error) {
      console.error('Failed to generate weekly analytics:', error);
    }
  }

  // Strategic replies for always-on education
  async performStrategicReplies() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping strategic replies');
      return;
    }

    try {
      console.log('🎯 Performing strategic reply engagement round...');
      await this.directXPoster.performEngagementRound();
    } catch (error) {
      console.error('Strategic replies failed:', error);
    }
  }

  // Post educational thread (weekly)
  async postEducationalThread() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping educational thread');
      return;
    }

    try {
      console.log('📚 Posting weekly educational thread...');
      const result = await this.directXPoster.postEducationalThread();
      
      if (result.success) {
        console.log(`✅ Educational thread posted successfully: ${result.threadUrl}`);
      } else {
        console.error(`❌ Educational thread failed: ${result.error}`);
      }
    } catch (error) {
      console.error('Educational thread posting failed:', error);
    }
  }

  // Daily analytics tracking
  async trackDailyAnalytics() {
    if (!xApiService.isReady()) {
      return;
    }

    try {
      console.log('📈 Tracking daily analytics...');
      
      const [dailySummary, conversions, contentAnalysis] = await Promise.all([
        xAnalyticsService.generateDailyAnalytics(),
        xAnalyticsService.trackConversionFunnel(),
        xAnalyticsService.analyzeContentPerformance()
      ]);

      console.log(`📊 Daily Summary: ${dailySummary.total_tweets} posts, ${dailySummary.avg_engagement_rate.toFixed(2)}% engagement`);
      console.log(`🎯 Conversions: ${conversions.follower_conversion.toFixed(2)}% follower→site, ${conversions.signup_conversion.toFixed(2)}% site→signup`);
      console.log(`🏆 Best content: ${contentAnalysis.best_content_type}`);

    } catch (error) {
      console.error('Daily analytics tracking failed:', error);
    }
  }

  // Real-time monitoring for immediate replies to priority accounts
  async monitorPriorityAccountsRealTime() {
    if (!xApiService.isReady()) {
      console.log('X API not configured - skipping priority account monitoring');
      return;
    }

    try {
      console.log('🚀 REAL-TIME: Monitoring priority RWA/CRE accounts...');
      await this.directXPoster.monitorPriorityAccounts();
    } catch (error) {
      console.error('Real-time priority monitoring failed:', error);
    }
  }

  async postCustomContent(text: string, options?: { poll?: { options: string[], duration_minutes: number }, media?: string[] }) {
    if (!xApiService.isReady()) {
      throw new Error('X API not configured');
    }

    const postData = {
      text,
      poll: options?.poll,
      media: options?.media
    };

    return await xApiService.postTweet(postData);
  }

  async generateMarketInsightPost(topic: string) {
    if (!xApiService.isReady()) {
      throw new Error('X API not configured');
    }

    try {
      // Use proper daily content generation with DALL-E images
      const insight = await xContentGeneratorFixed.generateDailyContent(new Date());
      
      console.log(`🎨 Generated content with ${insight.media?.length || 0} media files`);
      
      // Include media if generated
      const postData = {
        text: insight.text,
        media: insight.media || []
      };
      
      return await xApiService.postTweet(postData);
    } catch (error) {
      console.error('❌ Market insight generation failed:', error);
      
      // Fallback: Generate a beautiful DALL-E image manually
      const fallbackImage = await xContentGeneratorFixed.generatePostImage(
        'Professional commercial real estate office building with modern glass architecture and blockchain technology elements', 
        'market_insight'
      );
      
      const fallbackText = "Traditional real estate financing is getting more complex. Property owners need flexible solutions for accessing capital. Tokenization offers a new path to liquidity. Explore options at Commertize.com #Tokenization #RealWorldAssets #CommercialRealEstate #FinTech";
      
      const postData = {
        text: fallbackText,
        media: fallbackImage ? [fallbackImage] : []
      };
      
      console.log(`🔄 Using fallback with ${postData.media.length} media files`);
      return await xApiService.postTweet(postData);
    }
  }

  getStatus() {
    return {
      isRunning: this.isRunning,
      xApiReady: xApiService.isReady(),
      scheduledPosts: [
        { time: '9:00 AM PT', type: 'Morning Content' },
        { time: '3:00 PM PT', type: 'Afternoon Engagement' },
        { time: 'Every 30min', type: 'Mention Processing' },
        { time: 'Sunday 8AM PT', type: 'Weekly Analytics' }
      ]
    };
  }

  stop() {
    this.isRunning = false;
    console.log('X scheduler stopped');
  }
}

export const xScheduler = new XScheduler();
export default XScheduler;